---
description: 트러블슈팅 가이드 - 자주 발생하는 문제 및 해결 방법, 증권사 API, 데이터베이스, 스케줄러 문제
globs: ["**/*.py", "**/logs/*.log", "**/docker-compose.yml"]
alwaysApply: false
---

# 트러블슈팅 가이드

## 자주 발생하는 문제 및 해결 방법

### 1. 키움증권 API 관련 문제

#### 문제: 영웅문 프로그램 연결 실패
**증상**: `COM 객체를 생성할 수 없습니다` 오류
**원인**: 
- 영웅문 프로그램이 실행되지 않음
- COM 등록이 안됨
- 권한 부족

**해결 방법**:
```python
# 1. 영웅문 프로그램 실행 확인
import win32com.client
try:
    kiwoom = win32com.client.Dispatch("KHOPENAPI.KHOpenAPICtrl.1")
    print("영웅문 연결 성공")
except Exception as e:
    print(f"영웅문 연결 실패: {e}")
    # 영웅문 프로그램을 관리자 권한으로 실행 필요
```

#### 문제: API 호출 간격 제한
**증상**: `API 호출 제한` 오류
**원인**: 키움증권 API는 0.2초 이상 간격으로 호출해야 함

**해결 방법**:
```python
import time

def safe_api_call(func):
    def wrapper(*args, **kwargs):
        time.sleep(0.2)  # 최소 0.2초 대기
        return func(*args, **kwargs)
    return wrapper

@safe_api_call
def get_account_info():
    # API 호출
    pass
```

#### 문제: 로그인 실패
**증상**: `로그인 실패` 오류
**원인**: 
- 잘못된 계정 정보
- 인증서 문제
- 영웅문 버전 호환성

**해결 방법**:
```python
def login_with_retry(max_attempts=3):
    for attempt in range(max_attempts):
        try:
            # 로그인 시도
            result = kiwoom.CommConnect()
            if result == 0:  # 성공
                return True
        except Exception as e:
            print(f"로그인 시도 {attempt + 1} 실패: {e}")
            time.sleep(5)  # 5초 대기 후 재시도
    return False
```

### 2. 한국투자증권 API 관련 문제

#### 문제: API 인증 실패
**증상**: `401 Unauthorized` 오류
**원인**: 
- 잘못된 앱 키 또는 앱 시크릿
- 토큰 만료
- API 권한 부족

**해결 방법**:
```python
# 1. 앱 키/시크릿 확인
import os
print(f"App Key: {os.getenv('KIS_APP_KEY')}")
print(f"App Secret: {os.getenv('KIS_APP_SECRET')}")

# 2. 토큰 갱신
from app.utils.token_manager import TokenManager
token_manager = TokenManager(broker_name="kis")
token_manager.delete_token()  # 기존 토큰 삭제
# 새 토큰 발급 시도
```

#### 문제: 계좌 정보 조회 실패
**증상**: `계좌 정보가 설정되지 않았습니다` 오류
**원인**: 
- 환경변수에 계좌 정보가 설정되지 않음
- 잘못된 계좌번호 형식

**해결 방법**:
```bash
# env 파일에 계좌 정보 설정
KIS_ACCOUNT_8_PROD=64233408  # 계좌번호 앞 8자리
KIS_ACCOUNT_PD_PROD=22       # 계좌상품코드 2자리
```

#### 문제: API 응답 구조 오류
**증상**: `'list' object has no attribute 'get'` 오류
**원인**: 
- API 응답이 예상과 다른 구조
- output2가 리스트 형태로 반환됨

**해결 방법**:
```python
# API 응답 구조 처리 개선
if 'output2' in data:
    output2 = data['output2']
    if isinstance(output2, dict):
        # 딕셔너리 형태인 경우
        balance_info['cash_balance'] = float(output2.get('dnca_tot_amt', 0))
    elif isinstance(output2, list) and len(output2) > 0:
        # 리스트 형태인 경우 첫 번째 항목 사용
        output2_item = output2[0]
        balance_info['cash_balance'] = float(output2_item.get('dnca_tot_amt', 0))
```

#### 문제: 종목 가격 조회 실패
**증상**: `보유하지 않은 종목입니다` 오류
**원인**: 
- 보유하지 않은 종목의 가격 조회 시도
- 종목현재가조회 API 제거로 보유종목만 조회 가능

**해결 방법**:
```python
# 보유종목 조회 API만 사용
def get_stock_price(self, stock_code: str):
    """보유종목 조회 API를 통한 종목 가격 조회"""
    holdings = self.get_holdings(f"{self.account_8_prod}{self.account_pd_prod}")
    
    for holding in holdings:
        if holding.get('symbol') == stock_code:
            return {
                'stock_code': stock_code,
                'current_price': holding.get('current_price', 0),
                'change_rate': holding.get('profit_loss_rate', 0)
            }
    
    raise BrokerError(f"보유하지 않은 종목입니다: {stock_code}")
```

#### 문제: API 호출 제한
**증상**: `429 Too Many Requests` 오류
**원인**: API 호출 제한 초과

**해결 방법**:
```python
import time
from functools import wraps

def rate_limit(requests_per_second=10):
    """API 호출 제한 데코레이터"""
    min_interval = 1.0 / requests_per_second
    last_called = [0.0]
    
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            elapsed = time.time() - last_called[0]
            left_to_wait = min_interval - elapsed
            if left_to_wait > 0:
                time.sleep(left_to_wait)
            ret = func(*args, **kwargs)
            last_called[0] = time.time()
            return ret
        return wrapper
    return decorator

@rate_limit(requests_per_second=10)
def call_kis_api():
    # API 호출
    pass
```

### 3. 데이터베이스 관련 문제

#### 문제: 데이터베이스 락
**증상**: `database is locked` 오류
**원인**: 
- 동시 접근
- 트랜잭션 미완료
- 연결 누수

**해결 방법**:
```python
from sqlalchemy import create_engine
from sqlalchemy.pool import StaticPool

# SQLite 연결 설정
engine = create_engine(
    "sqlite:///./data/stock_analyzer.db",
    poolclass=StaticPool,
    connect_args={
        "check_same_thread": False,
        "timeout": 30  # 30초 타임아웃
    }
)

# 트랜잭션 관리
def safe_database_operation(func):
    def wrapper(*args, **kwargs):
        try:
            result = func(*args, **kwargs)
            db.commit()
            return result
        except Exception as e:
            db.rollback()
            raise e
        finally:
            db.close()
    return wrapper
```

#### 문제: 메모리 부족
**증상**: `MemoryError` 발생
**원인**: 대용량 데이터 처리

**해결 방법**:
```python
# 배치 처리
def process_large_dataset(data, batch_size=1000):
    """대용량 데이터 배치 처리"""
    for i in range(0, len(data), batch_size):
        batch = data[i:i + batch_size]
        process_batch(batch)
        # 메모리 정리
        del batch
        import gc
        gc.collect()

# 제너레이터 사용
def read_large_file(filename):
    """대용량 파일 스트리밍 읽기"""
    with open(filename, 'r') as f:
        for line in f:
            yield process_line(line)
```

### 4. 스케줄러 관련 문제

#### 문제: 스케줄러가 실행되지 않음
**증상**: 예약된 작업이 실행되지 않음
**원인**: 
- 스케줄러 설정 오류
- 시간대 설정 문제
- 프로세스 종료

**해결 방법**:
```python
# 스케줄러 상태 확인
def check_scheduler_status():
    """스케줄러 상태 확인"""
    scheduler = BackgroundScheduler()
    jobs = scheduler.get_jobs()
    
    for job in jobs:
        print(f"Job: {job.name}, Next run: {job.next_run_time}")
    
    return len(jobs) > 0

# 시간대 설정 확인
import pytz
from datetime import datetime

def check_timezone():
    """시간대 설정 확인"""
    seoul_tz = pytz.timezone('Asia/Seoul')
    now = datetime.now(seoul_tz)
    print(f"현재 시간 (서울): {now}")
```

#### 문제: 중복 실행
**증상**: 같은 작업이 여러 번 실행됨
**원인**: 스케줄러 중복 등록

**해결 방법**:
```python
# 중복 방지
def prevent_duplicate_execution(func):
    """중복 실행 방지 데코레이터"""
    import threading
    lock = threading.Lock()
    
    def wrapper(*args, **kwargs):
        if lock.acquire(blocking=False):
            try:
                return func(*args, **kwargs)
            finally:
                lock.release()
        else:
            print("이미 실행 중인 작업이 있습니다.")
    return wrapper
```

### 5. 네트워크 관련 문제

#### 문제: 연결 타임아웃
**증상**: `ConnectionTimeout` 오류
**원인**: 네트워크 불안정, 서버 응답 지연

**해결 방법**:
```python
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

def create_robust_session():
    """견고한 HTTP 세션 생성"""
    session = requests.Session()
    
    retry_strategy = Retry(
        total=3,
        backoff_factor=1,
        status_forcelist=[429, 500, 502, 503, 504],
    )
    
    adapter = HTTPAdapter(max_retries=retry_strategy)
    session.mount("http://", adapter)
    session.mount("https://", adapter)
    
    return session
```

#### 문제: SSL 인증서 오류
**증상**: `SSL: CERTIFICATE_VERIFY_FAILED` 오류
**원인**: 인증서 검증 실패

**해결 방법**:
```python
import ssl
import urllib3

# SSL 경고 비활성화 (개발 환경에서만)
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# SSL 검증 비활성화 (개발 환경에서만)
requests.packages.urllib3.disable_warnings()
```

### 6. 로깅 관련 문제

#### 문제: 로그 파일이 너무 커짐
**증상**: 디스크 공간 부족
**원인**: 로그 로테이션 설정 오류

**해결 방법**:
```python
import logging.handlers

def setup_rotating_logger():
    """로테이팅 로거 설정"""
    logger = logging.getLogger()
    handler = logging.handlers.RotatingFileHandler(
        'stock_analyzer.log',
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5
    )
    logger.addHandler(handler)
```

#### 문제: 민감정보 로깅
**증상**: 로그에 패스워드 등 민감정보 노출
**원인**: 마스킹 로직 누락

**해결 방법**:
```python
import re

class SensitiveDataFilter(logging.Filter):
    """민감정보 마스킹 필터"""
    
    def filter(self, record):
        if hasattr(record, 'msg'):
            record.msg = self.mask_sensitive_data(record.msg)
        return True
    
    def mask_sensitive_data(self, message):
        """민감정보 마스킹"""
        if not isinstance(message, str):
            return message
        
        # 패스워드 마스킹
        message = re.sub(
            r'password["\']?\s*[:=]\s*["\']?([^"\']+)["\']?',
            r'password="***"',
            message,
            flags=re.IGNORECASE
        )
        
        return message
```

### 7. 성능 관련 문제

#### 문제: 느린 데이터베이스 쿼리
**증상**: 쿼리 실행 시간이 오래 걸림
**원인**: 인덱스 부족, 비효율적인 쿼리

**해결 방법**:
```python
# 쿼리 최적화
def optimize_query():
    """쿼리 최적화"""
    # 인덱스 생성
    db.execute("CREATE INDEX IF NOT EXISTS idx_accounts_broker_id ON accounts(broker_id)")
    db.execute("CREATE INDEX IF NOT EXISTS idx_daily_balances_account_date ON daily_balances(account_id, date)")
    
    # 배치 처리
    def bulk_insert_balances(balances):
        db.bulk_insert_mappings(DailyBalance, balances)
        db.commit()
```

#### 문제: 메모리 누수
**증상**: 메모리 사용량이 계속 증가
**원인**: 객체 참조 누수, 가비지 컬렉션 부족

**해결 방법**:
```python
import gc
import weakref

def manage_memory():
    """메모리 관리"""
    # 가비지 컬렉션 강제 실행
    gc.collect()
    
    # 약한 참조 사용
    weak_refs = weakref.WeakValueDictionary()
    
    # 메모리 사용량 모니터링
    import psutil
    process = psutil.Process()
    memory_info = process.memory_info()
    print(f"메모리 사용량: {memory_info.rss / 1024 / 1024:.2f} MB")
```

### 8. 배포 관련 문제

#### 문제: Docker 컨테이너 시작 실패
**증상**: 컨테이너가 시작되지 않음
**원인**: 포트 충돌, 볼륨 마운트 오류

**해결 방법**:
```yaml
# docker-compose.yml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "8000:8000"
    volumes:
      - ./data:/app/data
      - ./logs:/app/logs
    environment:
      - DATABASE_TYPE=sqlite
      - DATABASE_PATH=/app/data/stock_analyzer.db
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
```

#### 문제: 환경변수 설정 오류
**증상**: 설정값이 제대로 로드되지 않음
**원인**: .env 파일 누락, 환경변수 이름 오류

**해결 방법**:
```python
from dotenv import load_dotenv
import os

def load_environment():
    """환경변수 로드"""
    load_dotenv()
    
    # 필수 환경변수 확인
    required_vars = ['DATABASE_TYPE', 'LOG_LEVEL']
    missing_vars = [var for var in required_vars if not os.getenv(var)]
    
    if missing_vars:
        raise ValueError(f"필수 환경변수가 설정되지 않았습니다: {missing_vars}")
```

## 모니터링 및 디버깅

### 1. 시스템 상태 모니터링
```python
import psutil
import logging

def monitor_system():
    """시스템 상태 모니터링"""
    logger = logging.getLogger(__name__)
    
    # CPU 사용률
    cpu_percent = psutil.cpu_percent(interval=1)
    logger.info(f"CPU 사용률: {cpu_percent}%")
    
    # 메모리 사용률
    memory = psutil.virtual_memory()
    logger.info(f"메모리 사용률: {memory.percent}%")
    
    # 디스크 사용률
    disk = psutil.disk_usage('/')
    logger.info(f"디스크 사용률: {disk.percent}%")
    
    # 경고 임계값
    if cpu_percent > 80:
        logger.warning("CPU 사용률이 높습니다!")
    if memory.percent > 80:
        logger.warning("메모리 사용률이 높습니다!")
```

### 2. 로그 분석
```python
def analyze_logs(log_file):
    """로그 파일 분석"""
    error_count = 0
    warning_count = 0
    error_messages = []
    
    with open(log_file, 'r') as f:
        for line in f:
            if 'ERROR' in line:
                error_count += 1
                error_messages.append(line.strip())
            elif 'WARNING' in line:
                warning_count += 1
    
    return {
        'error_count': error_count,
        'warning_count': warning_count,
        'error_messages': error_messages
    }
```

### 3. 성능 프로파일링
```python
import cProfile
import pstats
from functools import wraps

def profile_performance(func):
    """성능 프로파일링 데코레이터"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        profiler = cProfile.Profile()
        profiler.enable()
        result = func(*args, **kwargs)
        profiler.disable()
        
        stats = pstats.Stats(profiler)
        stats.sort_stats('cumulative')
        stats.print_stats(10)  # 상위 10개 함수만 출력
        
        return result
    return wrapper
```